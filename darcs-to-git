#!/usr/bin/env ruby
##
## Original Author: Steve Purcell, http://www.sanityinc.com/
## Author of this kludge: Thomas Schilling <nominolo@googlemail.com>
## Obtain the latest version of this software here: http://git.sanityinc.com/
##

# XXX: CLEAN THIS MESS UP

# TODO: use default repo if none was supplied

require 'ostruct'
require 'rexml/document'
require 'optparse'
require 'yaml' 

# Explicitly setting a time zone would cause darcs to only output in
# that timezone hence we couldn't get the actual patch TZ
# ENV['TZ'] = 'GMT0'

$start_time = Time.now

# GIT_DARCS_BRANCH = "darcs_repo"  # name of the branch we import to
GIT_PATCHES = ".git/darcs_patches"
AUTHOR_MAP_FILE = ".git/darcs_author_substitutions"

OPTIONS = { :default_email => nil,
            :list_authors  => false,
            :author_map    => nil,
            :num_patches   => 0 }
opts = OptionParser.new do |opts|
  opts.banner = "Creates git repositories from darcs repositories

  usage: darcs-to-git DARCSREPODIR [options]


1. Create an *empty* directory that will become the new git repository
2. From inside that directory, run this program, passing the location
   of the local source darcs repo as a parameter

The program will git-init the empty directory, and migrate all patches
in the source darcs repo into commits in that repository.

Thereafter, incremental patch conversion from the same source repo is
possible by repeating step 2.

NOTE: In case of multiple tags, the second one will override the first
one (this uses the git-branch -f flag, as by default Git does not
allow this).

OPTIONS

"
  opts.on('--default-email ADDRESS',
          "Set the email address used when no explicit address is given") do |m|
    OPTIONS[:default_email] = m
  end
  opts.on('--list-authors',
          "List all unique authors in source repo and quit.") do |m|
    OPTIONS[:list_authors] = m
  end
  opts.on('--author-map FILE',
          "Supply a YAML file that maps commiter names to canonical author names") do |f|
    OPTIONS[:author_map] = f
  end
  opts.on('--patches [N]', OptionParser::DecimalInteger,
          "Only pull N patches.") do |n|
    OPTIONS[:num_patches] = n
  end
end
opts.parse!

SRCREPO = ARGV[0]
if SRCREPO.nil? or not FileTest.exists?(SRCREPO + '/_darcs') then
  if SRCREPO.nil? then
    puts opts.banner()
    puts opts.summarize()
  else
    puts "Argument must be a valid local darcs repository"
  end
  exit(1)
end

def run(*args)
  puts "Running: #{args.inspect}"
  system(*args) || raise("Failed to run: #{args.inspect}")
end

def output_of(*args)
  puts "Running: #{args.inspect}"
  output = IO.popen(args.map {|a| "'#{a}'"}.join(' '), 'r') { |p| p.read }
  if $?.exitstatus == 0
    return output
  else
    raise "Failed to run: #{args.inspect}"
  end
end

# variant of output_of, but you have to check for success on your own
def output_nofail_of(*args)
  puts "Running: #{args.inspect}"
  output = IO.popen(args.map {|a| "'#{a}'"}.join(' '), 'r') { |p| p.read }
end

$darcs_time = 0.0
$git_time = 0.0

$darcs_patches_in_git = nil

class DarcsPatch
  attr_accessor :source_repo, :author, :date, :inverted, :identifier, :name, :is_tag, :git_tag_name, :comment, :local_date, :darcs_author
  attr_reader :author_name, :author_email

  def initialize(source_repo, patch_xml)
    self.source_repo = source_repo
    self.darcs_author = decode_darcs_escapes(patch_xml.attribute('author').value)
    self.author = AUTHOR_MAP.fetch(self.darcs_author, self.darcs_author)
    self.local_date = patch_xml.attribute('local_date').value
    self.date = darcs_date_to_git_date(patch_xml.attribute('date').value, self.local_date)
    self.inverted = (patch_xml.attribute('inverted').to_s == 'True')
    self.identifier = patch_xml.attribute('hash').to_s
    self.name = decode_darcs_escapes(patch_xml.get_elements('name').first.get_text.value) rescue 'Unnamed patch'
    self.comment = decode_darcs_escapes(patch_xml.get_elements('comment').first.get_text.value) rescue nil
    if (self.is_tag = (self.name =~ /^TAG (.*)/))
      self.git_tag_name = $1.gsub(/[\s:]+/, '_')
    end
    author_scan
  end

  def <=>(other)
    self.identifier <=> other.identifier
  end

  def git_commit_message
    [ ((inverted ? "UNDO: #{name}" : name) unless name =~ /^\[\w+ @ \d+\]/),
      comment
    ].compact.join("\n\n")
  end

  def self.read_from_repo(repo, n = nil)
    REXML::Document.new(output_of("darcs", "changes",
                                  n ? "--last=#{n}" : "--reverse",
                                  "--repodir=#{repo}", "--xml",
                                  "--summary")).
      get_elements('changelog/patch').map do |p|
      DarcsPatch.new(repo, p)
    end
  end

  def apply_to_git_repo
    ENV['GIT_AUTHOR_NAME'] = ENV['GIT_COMMITTER_NAME'] = author_name
    ENV['GIT_AUTHOR_EMAIL'] = ENV['GIT_COMMITTER_EMAIL'] = author_email
    ENV['GIT_AUTHOR_DATE'] = ENV['GIT_COMMITTER_DATE'] = date
    if is_tag
      in_repo = output_of("git-tag", "-l").split(/\r?\n/).include?(git_tag_name) &&
        output_of("git-rev-list", "--max-count=1", "tags/#{git_tag_name}").strip
      if in_repo then
        # force overriding the existing tag
        run("git-tag", "-f", "-a", "-m", git_commit_message, git_tag_name)
      else
        run("git-tag", "-a", "-m", git_commit_message, git_tag_name)
      end
    else
      new_files = git_new_files
      # explicitly delete any *-darcs-backup* files, they are
      # generated by darcs2 but don't show up under
      # "darcs whatsnew -sl"
      new_files.delete_if do |f|
        if f =~ /\-darcs\-backup.$/
          run("rm", f)
          true
        else
          false
        end
      end

      if new_files.any?
        run(*(["git-add"] + new_files))
      end

      if git_changed_files.any? || new_files.any?
        run("git-commit", "-a", "-m", git_commit_message)
      end

      # get full id of last commit and associate it with the patch id
      #commit_id = output_of("git-log", "-n1").scan(/^commit ([a-z0-9]+$)/).flatten.first
    end
  end

  private

  def author_scan
    @author_name, @author_email =
      if (author =~ /^\s*(\S.*?)\s*\<(\S+@\S+?)\>\s*$/)
        [$1, $2]
      elsif (author =~ /^\s*\<?(\S+@\S+?)\>?\s*$/)
        email = $1
        [email.split('@').first, email]
      else
        [author, OPTIONS[:default_email]]
      end
  end

  def decode_darcs_escapes(str)
    # darcs uses '[_\hh_]' to quote non-ascii characters where 'h' is
    # a hexadecimal.  We translate this to '=hh' and use ruby's unpack
    # to do replace this with the proper byte.
    str.gsub(/\[\_\\(..)\_\]/) { |x| "=#{$1}".unpack("M*")[0] }
  end

  def pull
    run("darcs", "pull", "--all", "--quiet",
        "--match", "hash #{identifier}",
        "--set-scripts-executable", source_repo)
    unless `darcs whatsnew -sl` =~ /^No changes!$/
      puts "Darcs reports dirty directory: assuming conflict that is fixed by a later patch... reverting"
      run("darcs revert --all")
      run("find . -name '*-darcs-backup0'|xargs rm")  # darcs2 creates these
    end
  end

  def darcs_date_to_git_date(utc,local)
    # Calculates a git-friendly date (e.g., timezone CET decribed as
    # +0100) by using the two date fields that darcs gives us: a list
    # of numbers describing the UTC time and a local time formatted in
    # a human-readable format.  We could parse the local time and
    # derive the timezone offset from the timezone name. but timezones
    # aren't well-defined, so we ignore the timezone name and instead
    # calculate the timezone offset ourselves by calculating the
    # difference between local time and ITC time.
    if not utc =~ /^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/ then
      raise "Wrong darcs date format"
    end
    utc_time = Time.utc($1,$2,$3,$4,$5,$6)
    # example: Mon Oct  2 14:23:28 CEST 2006
    # everything except timezone name is fixed-length, if parsing
    # failes we just use UTC
    if local =~ /^\w\w\w (\w\w\w) ([ 1-9]\d) ([ 0-9]\d)\:(\d\d)\:(\d\d) \w* (\d\d\d\d)/ then
      local_time = Time.utc($6,$1,$2,$3,$4,$5)
    else
      local_time = utc_time
    end
    offs = local_time - utc_time # time offset in seconds
    t = local_time
    # formats the above example as: 2006-10-02 14:23:28 +0200
    s = sprintf("%4d-%02d-%02d %02d:%02d:%02d %s%02d%02d",
                t.year, t.month, t.day,
                t.hour, t.min, t.sec,
                offs < 0 ? "-" : "+", offs.abs/3600, offs.abs.modulo(3600)/60 )
  end

  def git_ls_files(wanted)
    ls_files_out = 
      if FileTest.exists?(".gitignore") 
        output_of(*["git-ls-files", "-t", "-o", "-m", "-d", "-X", ".git/info/exclude", "-X", ".gitignore"])
      else
        output_of(*["git-ls-files", "-t", "-o", "-m", "-d", "-X", ".git/info/exclude"])
      end
    ls_files_out.scan(/^(.?) (.*?)$/m).map do |code, name|
      name if wanted.include?(code)
    end.compact
  end
  def git_new_files() git_ls_files(["?"]) end
  def git_changed_files() git_ls_files(%w(? R C)) end
end

def extract_authors(patches)
  unique_authors = {}
  patches.each do |p|
    unique_authors[p.author] =
      "#{p.author_name}" + (p.author_email.nil? ? "" : " <#{p.author_email}>")
  end
  puts "# You can use the following output as a starting point for an author_map"
  puts "# Just fill in the proper text after the colon;  put email addresses in"
  puts "# angle brackets. You can remove any lines that look OK to you."
  # TODO: Can we make the output sorted?
  puts YAML::dump( unique_authors )
end

def darcs_version
  output_of(*%w(darcs -v)).scan(/(\d+)\.(\d+)\.(\d+)/).flatten.map {|v| v.to_i}
end
class Array; include Comparable; end

unless darcs_version > [1, 0, 7]
  STDERR.write("WARNING: your darcs appears to be old, and may not work with this script\n")
end

unless File.directory?("_darcs")
  run("darcs", "init")
  run("git-init")
  File.open(".git/info/exclude", "a") { |f| f.write("_darcs\n.DS_Store\n") }
  File.open("_darcs/prefs/boring", "a") { |f| f.write("\\.git$\n\\.DS_Store$\n") }
  # TODO: migrate darcs borings into git excludes?
end

if OPTIONS[:default_email]
  run("git-config", "user.email", OPTIONS[:default_email])
end

if OPTIONS[:author_map] then
  unless FileTest.exists?(OPTIONS[:author_map])
    STDERR.puts "File #{OPTIONS[:author_map]} does not exist"
    exit(1)
  end
  begin
    AUTHOR_MAP = (YAML.load_file(OPTIONS[:author_map]) or {})
  rescue
    STDERR.puts "Could not parse #{(OPTIONS[:author_map])}"
    exit(1)
  end
  unless AUTHOR_MAP.class == Hash
    STDERR.puts "Wrong file format for author file."
    exit(1)
  end
  File.open("#{AUTHOR_MAP_FILE}", File::WRONLY|File::CREAT) do |f|
    YAML::dump(AUTHOR_MAP, f)
  end
else
  begin
    AUTHOR_MAP = (YAML.load_file(AUTHOR_MAP_FILE) or {})
  rescue
    AUTHOR_MAP = {}
  end
end

if OPTIONS[:list_authors] then
  patches = DarcsPatch.read_from_repo(SRCREPO)
  extract_authors(patches)
  exit(0)
end

$remaining = nil
def pull_patch_interactive(srcrepo)
  gotone = false
  author = nil
  local_date = nil
  name = nil
  puts "Running: darcs pull --set-scripts-executable #{srcrepo}"
  t0 = Time.now
  IO.popen("darcs pull --set-scripts-executable #{srcrepo}", "r+") do |f|
    f.putc "y"  # Yes, pull this patch
    f.putc "d"  # No, don't pull this patch and apply what we have so far
    while (l = f.gets)
      if not gotone and (l =~ /^(\w\w\w \w\w\w [ 1-9]\d [ 0-9]\d\:\d\d\:\d\d \w* \d\d\d\d)  (.+)/) then
        local_date = $1
        author = $2
        puts "Pulling patch:"
        puts "# #{l}"
      end
      if not gotone and (l =~ /^  (\*|tagged|UNDO\:) (.*)/) then
        name = $2
        puts "# #{l}"
      end
      if not gotone and (l =~ /^Shall I pull this patch\? \((\d+)\/(\d+)\)/) then
        # puts "# #{l}"
        $remaining = ($2.to_i - $1.to_i) rescue '?'
        gotone = true 
      end
    end
  end
  t1 = Time.now
  # XXX: we can be more accurate here
  unless `darcs whatsnew -s` =~ /^No changes!$/
    puts "Darcs reports dirty directory: assuming conflict that is fixed by a later patch... reverting"
    run("darcs revert --all")
  end
  $darcs_time += t1 - t0
    
  unless not gotone 
    patches = DarcsPatch.read_from_repo(".", 1)
    # puts "Patches: #{patches.length}"
    p = patches.first
    # Actually we have this assumption: 
    #   p.darcs_author == author &&
    #   p.local_date == local_date
    # but this fails with darcs2 as this uses curses or similar
    # techniques
    if true then 
      puts "\n" + ("=" * 80)
      puts "PATCH : #{p.name}"
      puts "DATE  : #{p.date}"
      puts "AUTHOR: #{p.author_name}"
      puts "EMAIL : #{p.author_email}"
      puts "=" * 80
      t2 = Time.now
      system("git-status")
      p.apply_to_git_repo
      t3 = Time.now
      $git_time += t3 - t2
      puts "Git commit: (#{$remaining} patches remaining)"
      puts ("-" * 80) + "\n"
    else
#       STDERR.puts "Ooops, last change is not what we pulled!"
#       STDERR.puts "Last patch (according to 'darcs changes')"
#       STDERR.puts "  #{p.local_date}  #{p.darcs_author}"
#       STDERR.puts "  * #{p.name}"
#       STDERR.puts "But we pulled:"
#       STDERR.puts "  #{local_date}  #{author}"
#       STDERR.puts "  * #{name}"
#       exit(1)
    end
  else
    puts "No more patches need to be pulled"
  end
  gotone
end

def check_consistent
  puts "Checking for consistency ..."
  system("diff", "-ur", "-x", "_darcs", "-x", ".git", ".", SRCREPO)
  ok = $? == 0
end

# check_consistent(patches_to_pull)

i = 0
while (gotone = pull_patch_interactive(SRCREPO))
  i += 1
  break if OPTIONS[:num_patches] > 0 and i >= OPTIONS[:num_patches]
  secs_day = 60*60*24
  secs_hour = 60*60
  total_time = Time.now - $start_time
  tpp = total_time / i
  r = ($remaining * tpp rescue 0)
  puts "Pulled patch #{i}%s" % 
    [ (OPTIONS[:num_patches] > 0 ? " (out of #{OPTIONS[:num_patches]} in this session)" : ""),
      $remaining ]

  puts "Time:    Darcs      Git     Total (per patch)  (Remaining)  "
  # puts "      ******** ******** ********* *********** ************  "
  puts "      %8.1f %8.1f %9.1f %11.1f  %2id %02ih %02im\n\n" %
    [ $darcs_time, $git_time, total_time, tpp,
      (r/secs_day).truncate, (r.modulo(secs_day)/secs_hour).truncate,
      (r.modulo(secs_hour)/60).truncate ]
  if i.modulo(50) == 0 then
    run("git-gc --auto")
  end
end

total_time = Time.now - $start_time
tpp = total_time / (i == 0 ? 1 : i)
puts "Time spent waiting for darcs:  %14.1f seconds" % $darcs_time
puts "Time spent waiting for git:    %14.1f seconds" % $git_time
puts "Total time spent:              %14.1f seconds" % total_time
puts "  -> time per patch            %14.1f seconds" % tpp
if (r = ($remaining * tpp rescue nil)) then
  secs_day = 60*60*24
  secs_hour = 60*60
  puts "  (approx. time remaining: %2i days %02i hours %02i minutes)" % 
    [ (r/secs_day).truncate, (r.modulo(secs_day)/secs_hour).truncate,
      (r.modulo(secs_hour)/60).truncate ]
end

unless gotone
  if not check_consistent then
    puts "!!! There were differences!  See diff above for details."
    puts "!!! It may be that the source repository was dirty."
    puts "!!! Run \"cd #{SRCREPO} && darcs whatsnew -sl\" to check."
    exit(1)
  end
end
puts "\nPulled #{i} patch#{i == 1 ? "" : "es"}" if i > 0

# Only do this on Sundays -- Yep, completely random choice.
if Time.now.wday == 0 then
  run( "git-gc --auto" )
  run( "darcs", "optimize" )
end


#mirror_last_commit(SRCREPO)
